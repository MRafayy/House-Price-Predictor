import torch
import numpy as np
import torch.nn as nn
import torch.optim as optim

# Load data
train = np.loadtxt('trainData.csv', delimiter=',', skiprows=1)
test = np.loadtxt('testData.csv', delimiter=',', skiprows=1)

xTrain = torch.tensor(train[:, :-1], dtype=torch.float32)
yTrain = torch.tensor(train[:, -1], dtype=torch.float32).unsqueeze(1)
xTest = torch.tensor(test[:, :-1], dtype=torch.float32)
yTest = torch.tensor(test[:, -1], dtype=torch.float32).unsqueeze(1)


np.random.seed(42)
torch.manual_seed(42)
device = 'cuda' if torch.cuda.is_available() else 'cpu'


xTrain, yTrain = xTrain.to(device), yTrain.to(device)
xTest, yTest = xTest.to(device), yTest.to(device)


class LinearRegression(nn.Module):
    def __init__(self):
        super(LinearRegression, self).__init__()
        self.linearLayer = nn.Linear(3, 1)

    def forward(self, x: torch.Tensor) -> torch.Tensor:
        return self.linearLayer(x)


model = LinearRegression().to(device)
lossFN = nn.MSELoss()
optim = torch.optim.Adam(model.parameters(), lr=0.1)

epochs = 10000
for epoch in range(epochs):
    model.train()
    output = model(xTrain)
    loss = lossFN(output, yTrain)
    optim.zero_grad()
    loss.backward()
    optim.step()

    model.eval()
    with torch.inference_mode():
      predictedPrice = model(xTest)
      testLoss = lossFN(predictedPrice, yTest)
      if (epoch + 1) % 1000 == 0:
        print(f"Epoch {epoch + 1} | Loss = {loss} | Test Loss = {testLoss}")
